#include "xparameters.h"
#include "xil_types.h"
#include "xil_printf.h"
#include "xil_exception.h"

int intr_flag, msec ;
volatile u32* timer_tcsr0_addr;
volatile u32* timer_tlr0_addr;
volatile u32* timer_tcr0_addr;

volatile u32* intc0_isr_addr;
volatile u32* intc0_ier_addr;
volatile u32* intc0_iar_addr;
volatile u32* intc0_ivr_addr;
volatile u32* intc0_mer_addr;

volatile u32* gpio_led_data_addr;
volatile u32* gpio_led_tri_addr;
volatile u32* gpio_sw_data_addr;
volatile u32* gpio_sw_tri_addr;
volatile u32* gpio_7_seg_cat_data_addr;
volatile u32* gpio_7_seg_cat_tri_addr;
volatile u32* gpio_7_seg_and_data_addr;
volatile u32* gpio_7_seg_and_tri_addr;
void TimerISR() {
    intr_flag = 1;
    msec += 200;

// Clear the pending interrupt
    *timer_tcsr0_addr |= (1 << 8);
    *intc0_iar_addr |= XPAR_AXI_TIMER_0_INTERRUPT_MASK;
}

void GlobalISR() { // Interrupt Service Routine
    u32 active_isr = *intc0_ivr_addr;

    switch (active_isr) {
    case XPAR_AXI_INTC_0_AXI_TIMER_0_INTERRUPT_INTR:
        TimerISR();
        break;
    case XPAR_AXI_INTC_0_AXI_UARTLITE_0_INTERRUPT_INTR:
    case XPAR_AXI_INTC_0_MAILBOX_0_INTERRUPT_0_INTR:
    case XPAR_AXI_INTC_0_MAILBOX_0_INTERRUPT_1_INTR:
    case XPAR_AXI_INTC_0_MAILBOX_1_INTERRUPT_0_INTR:
    case XPAR_AXI_INTC_0_MAILBOX_1_INTERRUPT_1_INTR:
    case XPAR_AXI_INTC_0_SW_0_INTR:
    case XPAR_AXI_INTC_0_SW_1_INTR:
    case XPAR_AXI_INTC_0_SW_2_INTR:
    case XPAR_AXI_INTC_0_SW_3_INTR:
    default:
        xil_printf("C%d: No handler for ISR=%x\r\n", XPAR_CPU_ID, active_isr);
        break;
    }
}

int main() {
    timer_tcsr0_addr = (u32*)(XPAR_TMRCTR_0_BASEADDR);
    timer_tlr0_addr = (u32*)(XPAR_TMRCTR_0_BASEADDR + 0x4);
    timer_tcr0_addr = (u32*)(XPAR_TMRCTR_0_BASEADDR + 0x8);

    intc0_isr_addr = (u32*)(XPAR_AXI_INTC_0_BASEADDR);
    intc0_ier_addr = (u32*)(XPAR_AXI_INTC_0_BASEADDR + 0x8);
    intc0_iar_addr = (u32*)(XPAR_AXI_INTC_0_BASEADDR + 0xC);
    intc0_ivr_addr = (u32*)(XPAR_AXI_INTC_0_BASEADDR + 0x18);
    intc0_mer_addr = (u32*)(XPAR_AXI_INTC_0_BASEADDR + 0x1C);

    gpio_led_data_addr = (u32*)(XPAR_AXI_GPIO_1_BASEADDR);
    gpio_led_tri_addr  = (u32*)(XPAR_AXI_GPIO_1_BASEADDR + 0x4);
    gpio_sw_data_addr  = (u32*)(XPAR_AXI_GPIO_1_BASEADDR + 0x8);
    gpio_sw_tri_addr   = (u32*)(XPAR_AXI_GPIO_1_BASEADDR + 0xC);
    gpio_7_seg_cat_data_addr = (u32*)(XPAR_AXI_GPIO_0_BASEADDR);
    gpio_7_seg_cat_tri_addr  = (u32*)(XPAR_AXI_GPIO_0_BASEADDR + 0x4);
    gpio_7_seg_and_data_addr = (u32*)(XPAR_AXI_GPIO_0_BASEADDR + 0x8);
    gpio_7_seg_and_tri_addr  = (u32*)(XPAR_AXI_GPIO_0_BASEADDR + 0xC);

// Set GPIOs as Input/Output
    *gpio_led_tri_addr = 0x0;
    *gpio_sw_tri_addr  = 0xFFFF;
    *gpio_7_seg_cat_tri_addr = 0x0;
    *gpio_7_seg_and_tri_addr = 0x0;
// Trun 1 element on PGEFDCBA
    u32 gpio_7_seg_cat = 0x08;
    u32 gpio_7_seg_and = 0x80;
    u32 gpio_led = 0x8000;
    u32 gpio_sw;

    *gpio_7_seg_cat_data_addr = gpio_7_seg_cat;
    *gpio_7_seg_and_data_addr = gpio_7_seg_and;
    *gpio_led_data_addr   = gpio_led;


// Set timer: enable interrupt | auto reload | count down
    *timer_tcsr0_addr = (1 << 6) | (1 << 4) | (1 << 1);
    *timer_tlr0_addr = 200000; // 0.2 second

// Set interrupt controller: enable interrupts generated by the timer
    *intc0_ier_addr |= XPAR_AXI_TIMER_0_INTERRUPT_MASK;
    *intc0_mer_addr = 0x3;

// Enable microblaze interrupt
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)GlobalISR, 0);
    Xil_ExceptionEnable();
    *timer_tcsr0_addr |= (1 << 7); // Start timer


#include <ctype.h>

    int Dec7Seg(char c, int has_dot) {
        int reg_val;

        switch (tolower(c)) {
        case '0': reg_val = 0xC0; break;
        case '1': reg_val = 0xF9; break;
        case '2': reg_val = 0xA4; break;
        case '3': reg_val = 0xB0; break;
        case '4': reg_val = 0x99; break;
        case '5': reg_val = 0x92; break;
        case '6': reg_val = 0x82; break;
        case '7': reg_val = 0xF8; break;
        case '8': reg_val = 0x80; break;
        case '9': reg_val = 0x90; break;
        case 'a': reg_val = 0x88; break;
        case 'b': reg_val = 0x83; break;
        case 'c': reg_val = 0xC6; break;
        case 'd': reg_val = 0xA1; break;
        case 'e': reg_val = 0x86; break;
        case 'f': reg_val = 0x8E; break;
        case 'g': reg_val = 0x92; break;
        case 'h': reg_val = 0x89; break;
        case 'i': reg_val = 0xF9; break;
        case 'j': reg_val = 0xF1; break;
        case 'k': reg_val = 0x8B; break;
        case 'l': reg_val = 0xC7; break;
        case 'm': reg_val = 0xAA; break;
        case 'n': reg_val = 0xAB; break;
        case 'o': reg_val = 0xA3; break;
        case 'p': reg_val = 0x8C; break;
        case 'q': reg_val = 0x98; break;
        case 'r': reg_val = 0xAF; break;
        case 's': reg_val = 0x92; break;
        case 't': reg_val = 0x87; break;
        case 'u': reg_val = 0xC1; break;
        case 'v': reg_val = 0xC3; break;
        case 'w': reg_val = 0xD5; break;
        case 'x': reg_val = 0x89; break;
        case 'y': reg_val = 0x91; break;
        case 'z': reg_val = 0xA4; break;
        case '-': reg_val = 0xBF; break;
        case '_': reg_val = 0xF7; break;
        case ' ': reg_val = 0xFF; break;
        default:  reg_val = 0xFF; break;
        }

        if (has_dot) {
            reg_val &= 0x7F;
        }

        return reg_val;
    }


    while (1) {
        if (intr_flag) {
            // PGEFDCBA
            switch (gpio_7_seg_and) {
            case 0x80: *gpio_7_seg_cat_data_addr = ~0xFF; break;

            case (0x80 >> 1): *gpio_7_seg_cat_data_addr = ~0x16; break; // 2 -> 00010100

            }

            gpio_7_seg_and = gpio_7_seg_and >> 1;
            if (!gpio_7_seg_and) {
                gpio_7_seg_and = 0x80;
            }
            *gpio_7_seg_and_data_addr = ~gpio_7_seg_and;

            gpio_led = gpio_led >> 1;
            if (!gpio_led) {
                gpio_led = 0x8000;
            }
            gpio_sw = *gpio_sw_data_addr;
            *gpio_led_data_addr = gpio_led & ~gpio_sw;

            //xil_printf("C%d: %d ms\r\n", XPAR_CPU_ID, msec);
            intr_flag = 0;
        }
    }


    return 0;
}